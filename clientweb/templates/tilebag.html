<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
  <link rel="shortcut icon" href="{{ url_for('.static', filename='favicon.ico') }}">
  <link rel="stylesheet" href="{{ url_for('.static', filename='tilebag.css') }}{{ cachefix }}">
  <link rel="stylesheet" href="{{ url_for('.static', filename='ticker.css') }}{{ cachefix }}">
  <link rel="stylesheet" href="{{ url_for('.static', filename='board.css') }}{{ cachefix }}">
   
  <!-- Include our javascript helpers -->
  <script src="{{ url_for('.static', filename='board.js') }}{{ cachefix }}"></script>
  <script src="{{ url_for('.static', filename='tiles.js') }}{{ cachefix }}"> </script>
  <script src="{{ url_for('.static', filename='tbREST.js') }}{{ cachefix }}"> </script>
    
   <!-- And our WebSocket helper -->
  <script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js" integrity="sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=" crossorigin="anonymous"></script>
   
</head>
<body>

<div class="header">
  <h1>TileBag!</h1>
</div>

<div class="mstick" id="messagebar">
  <div class="messages">
    <div class="gamestate" id="gamestate"></div>
    <div class="gamemessage" id="gamemessage"></div>
  </div>
</div>

<div class="row">
  <div class="infocolumn">
    <h2 style="text-align:center">PLAYERS</h2>
    <div class="playerlist" id="playerlist">
      <!-- This will get populated with the player names -->
    </div>
    <h2 style="text-align:center">GAME LOG</h2>
    <div class="card">
      <div class="messagelog"><ul id="messagelog"></ul></div>
    </div>
  </div>
  <div class="maincolumn">
    <div class="card notthere" id="vspectator">
      <h2>SPECTATORS</h2>
      <p>So you're just watching the game?</p>
      <div class="topnav" id="players"></div>
    </div>
    <div class="card notthere" id="vtiles">
      <h2>TILES</h2>
      <div class="tilerack" id="tilerack">
        <!-- The following will dynamically be populated with
        <div class="rackspace"></div>
             And each will eventually get populated with
        <div class="tile"><ctext>X</ctext><rtext>X</rtext></div>
        -->
      </div>
    </div>
    <div class="card notthere" id="vbuystocks">
      <h2>BUY STOCKS</h2>
      <button onclick="passTurn()" id="btnPass">Pass</button>
    </div>
    <div class="card notthere" id="vselecthotel">
      <h2>SELECT HOTEL</h2>
    </div>
    <div class="card notthere" id="vstockoptions">
      <h2>STOCK OPTIONS</h2>
    </div>
    <div class="card notthere" id="vendgameinfo">
      <h2>END GAME SUMMARY</h2>
    </div>
    <div class="card">
      <div class="row">
        <div class="hotelcolumn">
          <div class=row>
            <h2 class="left60">HOTELS</h2>
            <button onclick="clrCnt('H')" class="right30 clr" id="btnClearHCnt">Clear</button>
          </div>
          <div class="hotellist" id="hotellist">
          </div>
        </div>
        <div class="boardcolumn">
          <div class=row>
            <h2 class="left60">BOARD</h2>
            <button onclick="onEndGame()" class="right30 clr" id="btnEndGame">Trigger Game End</button>
          </div>
          <div class="acquireBoard" style="height:300px;" id="acquireBoard"></div>
          <div class="row">
            <div id="outer">
              <!-- This div is important! 
              It lets us specify margin-left as percentage (in css loop) -->
              <div>
                  <div id="loop"><div id="content">Welcome to TileBag!&nbsp;</div></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="footer">
  <div class="card">
  <button type="button" class="collapsible">Instructions</button>
  <div class="content">
    <p>Instruction: Most game actions are completed by dragging elements</p>
    <ul style="text-align:left">
      <li>Place a Tile - Drag tile to the board</li>
      <li>Buy a Stock - Drag hotel to the stock market</li>
      <li>Sell a Stock - Drag stock to the hotel area</li>
      <li>Place a Hotel - Click a tile on the board, Drag hotel to the board</li>
      <li>Remove a Hotel - Drag hotel to the "Remove" area</li>
    </ul>
  </div>
  </div>
  <div class="card">
  <div class="hotellist"><img src="{{ url_for('.static', filename='stockchart.jpg') }}" alt="STOCK CHART" ></img></div>
  <h2>Footer</h2>
  </div>
</div>

<!-- ################################################################### --> 
<!-- ## Javascript for Rendering Game Components on the Screen -->
<!-- ################################################################### --> 
  <script>

  /* The hotel constants */
  let HOTELS = [
       {name: "Worldwide", short: "WW", color: "rgba(87, 54, 107, 1)"},
       {name: "Saxxon", short: "SX", color: "rgba(199, 140, 68, 1)"},
       {name: "Festival", short: "FV", color: "rgba(39, 117, 39, 1)"},
       {name: "Imperial", short: "IM", color:"rgba(181, 149, 45, 1)"},
       {name: "American", short: "AM", color: "rgba(45, 51, 140, 1)"},
       {name: "Continental", short: "CN", color: "rgba(156, 57, 26, 1)"},
       {name: "Tower", short: "TW", color: "rgba(115, 113, 112, 1)"},
   ];
    
  // The main window components we'll reference the most
  const el_gamestate=document.getElementById('gamestate');
  const el_gamemessage=document.getElementById('gamemessage');
  const el_playerlist=document.getElementById('playerlist');
  const el_hotellist=document.getElementById("hotellist");
  const el_gameboard=document.getElementById("acquireBoard")
  const el_tilerack=document.getElementById("tilerack");
   
  // The game UI "cards" that come and go based on state
  const el_vspectator=document.getElementById("vspectator");
  const el_vtiles=document.getElementById("vtiles");
  const el_vbuystocks=document.getElementById("vbuystocks");
  const el_vselecthotel=document.getElementById("vselecthotel");
  const el_vstockoptions=document.getElementById("vstockoptions");
  const el_vendgameinfo=document.getElementById("vendgameinfo");

  // Helper functions
  const EFFECT_REMOVED='notthere';
  const EFFECT_ERROR='error';
  const EFFECT_HIGHLIGHT='highlight';
  const EFFECT_SHOW='visible';
  const EFFECT_INDICATE='indicate';
  function addEffect(effect, elem) {
    if( !elem.className.includes(" " + effect) ) {
      elem.className = elem.className + " " + effect;
    }
  }
  function removeEffect(effect, elem) {
    elem.className = elem.className.replace(" " + effect, "");
  }
  </script>
      
<!-- ################################################################### --> 
<!-- ## Javascript for Dynamic Game Effects from User actions -->
<!-- ################################################################### --> 
  <script>
  el_gameboard.addEventListener('playtile', tileDropped);
  el_gameboard.addEventListener('placehotel', placeHotel);
  //el_stockrack.addEventListener('buystock', buyStock);
  el_hotellist.addEventListener('sellstock', sellStock);

  /* For TILES */
  function tileDropped(e){
    tile=e.detail.tile;
    if( {{debug}}  ) {
      tile.parentNode.removeChild(tile);
      placeTile(tile.innerText);
    } else {
      makeGameMove(tile); // post the move to the game server
    }
  }

  function onEndGame() {
    console.log("onEndGame pressed");
    sendEndGameRequest();
  }
   
  async function sendEndGameRequest() {
    await tbREST_requestEndGame("{{ url_for('tilebagrest_blueprint.rest_tilebag_get_game_info', gameid=gameid, playerid=playerid) }}")
            .catch( err => { sendGameMessage(err.message); });
  }
     
  async function makeGameMove(tile)
  {
    await tbREST_placetile("{{ url_for('tilebagrest_blueprint.rest_tilebag_placetile', gameid=gameid, playerid=playerid) }}", tile.innerText)
            .then( result => tile.parentNode.removeChild(tile) )
            .catch( err => { sendGameMessage(err.message);
                          });
  }
   
  /* For HOTELS */
  async function placeHotel(e){
    hel=e.detail.tile;
    await tbREST_placeHotel("{{ url_for('tilebagrest_blueprint.rest_tilebag_placehotel', gameid=gameid, playerid=playerid) }}", hel.id, 'lastplaced')
            .catch( err => { sendGameMessage(err.message);
                          });
  }

  async function removeHotel(e){
    hel=e.detail.tile;
    await tbREST_placeHotel("{{ url_for('tilebagrest_blueprint.rest_tilebag_placehotel', gameid=gameid, playerid=playerid) }}", hel.id, null)
            .catch( err => { sendGameMessage(err.message);
                          });
  }

  // Called when a hotel tile starts or stops being dragged
  function onHotelDrag(hotel, done=false) {
  }

  function getMultiSelectId(itemtype, hname) {
    return "ms_" + itemtype + "_" + hname;
  }

  function addMultiSelect(hostelm, itemtype) {
    var ms = document.createElement('span');
    ms.className="mscount";
    ms.id = getMultiSelectId(itemtype, hostelm.dataset.hotel);
    ms.dataset.count=0;
    hostelm.appendChild(ms);
    hostelm.onclick=function() {onMultiSelectClick(ms, itemtype);};
  }

  function _clrCnt(h, itemtype) {
    var elCnt=document.getElementById(getMultiSelectId(itemtype, h.name));
    elCnt.dataset.count=0;
    removeEffect(EFFECT_SHOW, elCnt);
  }

  function passTurn() {
    stockAction("Passing", 0);

    // Hide the button
    var elBtnPass=document.getElementById("btnPass");
    removeEffect(EFFECT_SHOW, elBtnPass);
  }

  function clrCnt(itemtype) {
    // Go through all count items, reset them and hide them
    HOTELS.forEach(h => _clrCnt(h, itemtype));
    // Hide the Clear Button
    var elClrStock=document.getElementById("btnClear"+itemtype+"Cnt");
    removeEffect(EFFECT_SHOW, elClrStock);
  }

  function onMultiSelectClick(mselem, itemtype) {
    if( mselem.parentElement.dataset.hasmoved == "false" )
    {
      var reqcount=parseInt(mselem.dataset.count);
      reqcount = isNaN(reqcount) ? 1 : reqcount+1;
      clrCnt(itemtype); // clear all others
      mselem.innerText=reqcount
      mselem.dataset.count=reqcount;
      addEffect(EFFECT_SHOW,mselem);
      var elClrBtn=document.getElementById("btnClear"+itemtype+"Cnt");
      addEffect(EFFECT_SHOW,elClrBtn);
    }
  }

  function getCountFromMultSelect(itemtype, hname) {
    var elw=document.getElementById(getMultiSelectId(itemtype, hname));
    var count = 1;
    if( elw != undefined )
    {
      count=parseInt(elw.dataset.count);
      if( isNaN(count) || count == 0) {
        count = 1;
      }
       
      // Clear the "count" value from the element
      elw.dataset.count=0;
      removeEffect(EFFECT_SHOW, elw);
    }
    return count;
  }
   
  /* For STOCKS */
  function buyStock(e){
    // called with a hotelitem object
    var hotel=e.detail.tile;
    var hname=hotel.dataset.hotel;
    var buyCount=getCountFromMultSelect('H', hname);
     
    stockAction(hname, buyCount);
     
    var elClrHotel=document.getElementById("btnClearHCnt");
    removeEffect(EFFECT_SHOW, elClrHotel);
  }
   
  function sellStock(e){
    // called with a stockitem object
    var si=e.detail.tile;
    var hname=si.dataset.hotel;
    var sellCount=getCountFromMultSelect('S', hname);
       
    stockAction(hname, -sellCount);
     
    var elClrHotel=document.getElementById("btnClearSCnt");
    removeEffect(EFFECT_SHOW, elClrHotel);
  }
   
  async function stockAction(hname, amt){
    // make REST call to change player hotel amounts by this
    await tbREST_stockAction("{{ url_for('tilebagrest_blueprint.rest_tilebag_stocks', gameid=gameid, playerid=playerid) }}", hname, amt)
            .catch( err => {
                            sendGameMessage(err.message);
                           });
  }
   
  </script>
   
<!-- ################################################################### --> 
<!-- ## Javascript for Dynamic Game Effects from Server Messages -->
<!-- ################################################################### --> 
  <script>

  function sendGameMessage(message, error=true) {
    console.log(message);
    el_gamemessage.innerText=message;
     
    // Set the message, show it, and schedule the fade-out timer
    removeEffect(EFFECT_REMOVED, el_gamemessage)
    if( error ) {
      addEffect(EFFECT_ERROR, el_gamemessage);
    }
    setTimeout(function(){
      removeEffect(EFFECT_ERROR, el_gamemessage);
      addEffect(EFFECT_REMOVED, el_gamemessage);
      }, 2500);
  }
     
  function showHotel(dhotel, ticker) {
    let h=HOTELS.find(o => o.name === dhotel['name']);
    let hel=document.getElementById(dhotel['name']);

    // Update the remaining stock count
    var sc=document.getElementById("sc_" + h.name);
    sc.innerText=dhotel['stocks'];
       
    // If it's on the board, show it on the board
    if( dhotel['tile'] != null) {
      // Update the stock ticker
      var sti=document.createElement('span');
      sti.style.color=h.color;
      sti.innerText=h.short+"("+dhotel['occupies'].length+") $" + dhotel['price'] + ";   ";
      ticker.appendChild(sti);
       
      // Colour the tiles on the board
      for( var i=0; i<dhotel['occupies'].length; i++)
      {
        var t = dhotel['occupies'][i];
        var cell=document.getElementById(t);
        if( cell != null)
        {
          cell.style.backgroundColor=h.color;
          cell.style.borderColor=h.color;
          cell.innerText = h.short;
          cell.style.fontSize="small";
          cell.className = cell.className + " honboard";
        }
      }

      // Tweak the hotel widget so it's clear it's on the board
      if( !hel.className.includes(" honboard") ) {
        hel.className = hel.className + " honboard";
      }
    }
    else
    {
      hel.className=hel.className.replace(" honboard", "");
    }
     
    // Grey out the widget based on how many stocks are left
    st=parseInt(dhotel['stocks']);
    var decksize = st / 25;
    if(st > 0){
      decksize += 0.5;
    }
    hel.style.opacity=decksize + 0.2;
  }
   
  // game info only includes stocks we have, the rest are Zero
  function updateStocks(h, pstocks) {
    var stockval=0;
    var si=document.getElementById("st_" + h.short + "_cnt");
    if( pstocks[h.name] != undefined )
    {
      stockval=pstocks[h.name];
    }
    si.innerText=stockval;
  }

  // For the stock TICKER
  function repeatTickerContent(el, till) {
    let html = el.innerHTML;
    let counter = 0; // prevents infinite loop

    while (el.offsetWidth < till && counter < 100) {
        el.innerHTML += html;
        counter += 1;
    }
  }

  function setTickerToString(tickerstring) {
    elt=document.createElement('div');
    elt.innerText=tickerstring;
    drawTickerWithElement(elt);
  }

  function drawTickerWithElement(elt) {
    el_outer=document.getElementById('outer');
    el_loop=el_outer.querySelector('#loop');
     
    elt.className='content';
    el_loop.innerHTML="";           // clear the stock ticker first
    el_loop.appendChild(elt);
    repeatTickerContent(elt, el_outer.offsetWidth);
    el_loop.innerHTML=el_loop.innerHTML+el_loop.innerHTML;
  }

  const HTML_PLAYER_NAME='<div class="row"><div class="left60">YYYYYY</div><span class="right30 activeind" id="pactive_XXXXXX"></span></div>';
   
  const HTML_ACTIVE_PLAYER='<div class="card">'+HTML_PLAYER_NAME+'<div class="playerspace"><div class="row"><div class="left60">STOCK MARKET</div><span class="right30 playermoney" id="playermoney">$$$$$</span> </div> <div class="stockrack" id="stockrack"> <!-- The following will dynamically be populated with <div class="stockspace">M</div> --></div><div class="row notthere" id="forbuttons">For Buttons</div></div></div>';
   
  function showPlayers(pdata, you) {
    var pid=pdata['id'];         // Shorthand for this function
    var pname=pdata['name'];

    // Create a container for the player to show up
    var elc=document.createElement('div');
    elc.className="card playercard";
    elc.id='playerind_'+pid;
    el_playerlist.appendChild(elc);
       
    // Create the details of the player
    var elps=document.createElement('div');
    if( you ) {
      elps.innerHTML=HTML_ACTIVE_PLAYER;
    } else {
      elps.innerHTML=HTML_PLAYER_NAME;
    }
    elps.innerHTML = elps.innerHTML.replace(/XXXXXX/g, pid);
    elps.innerHTML = elps.innerHTML.replace(/YYYYYY/g, pname);
    elc.appendChild(elps);

    if( you ) {
      // Dynamically add the STOCKS widgets to the player area
      const buildStockWidget = function(hotel){
        // First Create the space for the stock item
        var ss=document.createElement('div');
        ss.className="stockspace";
        var elsr=document.getElementById("stockrack");
        elsr.append(ss);
         
        // Then create the individual stock and put it in that space
        var si=document.createElement('div');
        si.className="stockitem";
        si.id = "st_" + hotel.short;
        si.dataset.hotel=hotel.name; // required for multi-select
        si.style.backgroundColor=hotel.color;
        ss.append(si);
         
        var sia=document.createElement('div');
        sia.className="stockcount";
        var sib=document.createElement('div');
        sia.id=si.id + "_cnt";
        sia.innerText=0;
        sib.innerText=hotel.short;
        si.append(sia);
        si.append(sib);
      }
      HOTELS.forEach(h => buildStockWidget(h));
    }
  }

  // render things that will stay static for the rest of the game
  function renderInitialGameParts(data) {
    // PLAYERS
    var players=data['game']['players']; // shorthand for player list
    var pdata=null;  // THIS player
    var start=0; // Index into the player list for THIS player
     
    // always show the player at the top of the player list
    if( data['game']['you'] ) {
      pdata=data['game']['you'];
      for(var i=0; i<players.length; i++)
      {
        if( pdata['id'] == players[i]['id'] ){
          start=i;
          break;
        }
      }
    }

    // show all of the players in a list
    for(var i=0; i<players.length; i++)
    {
      showPlayers(players[(start+i)%players.length], i==0 ? pdata : null);
    }
  }
   
  // Elements that every viewer should see
  function renderCommonView(data) {
    // GAMESTATE
    el_gamestate.innerText=data['game']['gamestate']['message'];
     
    // GAMELOG: Show the last messages
    var el_msgLog=document.getElementById("messagelog");
    var msgs=data['game']['gamelog'];
    el_msgLog.innerHTML="";
    for(var i=0; i<msgs.length; i++) {
      var li=document.createElement("li");
      var t=document.createTextNode(msgs[i]);
      li.appendChild(t);
      el_msgLog.appendChild(li);
    }
     
    // Highlight the current player
    var currpid=data['game']['gamestate']['currplayer']['id'];    
    var elp=document.getElementById("playerind_"+currpid);
    var x = document.querySelectorAll(".playercard");
    for(var i = 0; i < x.length; i++) {
      if( x[i] != elp ){
        removeEffect(EFFECT_INDICATE, x[i]);
      }
    }
    addEffect(EFFECT_INDICATE, elp);
     
    // BOARD: Draw the board
    drawBoard(el_gameboard,data['game']['board']); // from board.js
     
    // HOTELS: Place the hotel tokens on the board
    elt=document.createElement('div');
    var hotels=data['game']['hotels'];
    hotels.forEach(h => showHotel(h,elt));
     
    // Draw the stock TICKER
    drawTickerWithElement(elt);

  }
   
  // Elements that are unique to a spectator
  function renderSpectatorView(data) {
    removeEffect(EFFECT_REMOVED, el_spectator);
  }
   
  function renderPlayerViewWhenActive(data) {
    var state=data['game']['gamestate']['state']
    switch( state ) {
    case 'EndGame':
      removeEffect(EFFECT_REMOVED, el_vendgameinfo);
      break;
    case 'BuyStocks':
      removeEffect(EFFECT_REMOVED, el_vbuystocks);
      break;
    case 'SelectMergeWinner':
    case 'SelectMergeLoser':
    case 'PlaceHotel':
      removeEffect(EFFECT_REMOVED, el_vselecthotel);
      break;
    case 'LiquidateStocks':
      removeEffect(EFFECT_REMOVED, el_vstockoptions);
      break;
    }
  }

  // Elements that are unique to the palyer
  function renderPlayerView(data) {
    var pinfo=data['game']['you']['playerdata'];
    var currpid=data['game']['gamestate']['currplayer']['id'];
    var thispid=data['game']['you']['id'];
     
    // MONEY
    var elpmoney=document.getElementById('playermoney');
    elpmoney.innerText=(new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0,})).format(pinfo['money']);

    // STOCKS
    stocks=pinfo['stocks'];
    HOTELS.forEach(h => updateStocks(h, stocks));

    // TILE RACK
    tiles=pinfo['tiles'];
    setTiles("rackspace", tiles, [[el_gameboard, 'playtile']]);
    showOptions(tiles);

    // GAME STATE Specific views (reset what's visible every time)
    addEffect(EFFECT_REMOVED, el_vendgameinfo);
    addEffect(EFFECT_REMOVED, el_vbuystocks);
    addEffect(EFFECT_REMOVED, el_vselecthotel);
    addEffect(EFFECT_REMOVED, el_vstockoptions);
    removeEffect(EFFECT_REMOVED, el_vtiles); // tiles always visible? TBD
    if( thispid == currpid ) {
      addEffect(EFFECT_HIGHLIGHT, el_gamestate);
      renderPlayerViewWhenActive(data);
    } else {
      removeEffect(EFFECT_HIGHLIGHT, el_gamestate);
    }

  }
   
  var bInitialRender=true;
  async function rendergame(data) {
    // You may have realized that no where do we call this function with
    // data defined... that may change if I supply the game state info in the
    // websocket poke
    if( data === undefined ) {
      data=await tbREST_getGameState("{{ url_for('tilebagrest_blueprint.rest_tilebag_get_game_info', gameid=gameid, playerid=playerid) }}")
            .catch( err => { sendGameMessage(err.message); return;});
    }

    // some things, like the player info needs to be dynamically created,
    // but only once
    if( bInitialRender ) {
      renderInitialGameParts(data);
      bInitialRender = false;
    }

    // some things are shown regardless of who's viewing
    renderCommonView(data)
     
    if( data['game']['you'] ) {
      // some things are only for the player
      renderPlayerView(data)
    } else {
      // some things are for spectators
      renderSpectatorView(data)
    }
     
   /*
    // display GAMESTATE: Show the current action we're waiting on
    var currpname=data['game']['gamestate']['currplayer']['name'];
    var currpid=data['game']['gamestate']['currplayer']['id'];
    //el_currplayer.innerText=data['game']['gamestate']['message'];
     
    if( data['game']['endpossible'] ) {
      addEffect(EFFECT_SHOW, el_btnEndGame);
    } else {
      removeEffect(EFFECT_SHOW, el_btnEndGame);
    }

    } else {
      removeEffect(EFFECT_REMOVED, el_vtiles);
      addEffect(EFFECT_REMOVED, el_spectator);
       
      
       
      // Display STATE specific elements
      // Done last so it can override other items... damn this code is sloppy
      var elBtnPass=document.getElementById("btnPass");
      var state=data['game']['gamestate']['state']
      if( state == 'EndGame') {
        setTickerToString("Game Over ");
      }
      if( state != 'BuyStocks' &&
          state != 'LiquidateStocks') { 
        removeEffect(EFFECT_SHOW, elBtnPass);
      }
    }
    */
  }
  </script>
         
          
<!-- ################################################################### --> 
<!-- ## Javascript for loading / initializing the game -->
<!-- ################################################################### --> 
  <script>

  // Set up the game
  setupWebSocket();
  setupStaticGameParts();
  rendergame();
  sendGameMessage("Welcome!", false);
   
  function setupStaticGameParts() {
    // For TILERACK
    // Dynamically create the spots for the tiles
    // <div class="rackspace"></div>
    for(var i=0; i<7; i++){
      var rs=document.createElement('div');
      rs.className="rackspace";
      el_tilerack.append(rs);
    }
     
    // Draw the BOARD
    drawBoard(el_gameboard); // from board.js - draws an empty board
   
    // Dynamically add the HOTELS tokens to the page
    const buildHotelName = function(hotel){
      // first create the space for the hotel item
      var hs=document.createElement('div');
      hs.className="hotelspace";
      el_hotellist.appendChild(hs);
       
      // then create the individual hotel and put it in that space
      var hi = document.createElement('div');
      hi.className="hotelitem";
      hi.id = hotel.name;
      hi.dataset.hotel=hotel.name;
      hs.appendChild(hi);
      hi.innerText=hotel.name;
      hi.dataset.hasmoved=false;
      hi.style.backgroundColor=hi.style.backgroundColor + " " +  hotel.color;
      hi.style.borderColor=hotel.color;

      // create the "hidden" multi-select count part
      addMultiSelect(hi, "H");
       
      // create the remaining stock count part
      var sc = document.createElement('span');
      sc.className="rmstockcount";
      sc.id = "sc_" + hotel.name;
      sc.innerText="#";
      hi.appendChild(sc)
       
      // drop hotel on stocks to buy stock, on board to place hotel
      makeTileDragable(hi, [/*[el_stockrack, 'buystock'],*/
                            [el_gameboard, 'placehotel'],
                            /*[el_rmhotelzone, 'rmhotel']*/], onHotelDrag);
    }
    HOTELS.forEach(h => buildHotelName(h));
     
    enableCollapsables();
  }

  function setupWebSocket() {
    var url=location.protocol + '//{{ serverroot }}';
    var socket = io.connect(url, {
                   'transports': ['websocket'],
                   'reconnection': true,
                 'reconnectionDelay': 1000,
                 'reconnectionDelayMax': 5000,
                 'reconnectionAttempts': 5,
              });
    socket.emit('join', {'room':'{{ gameid }}'});     
    socket.on('connect', function() {
        console.log("*** WS:Connected: " + url);
    });

    socket.on('update', function(data) {
      console.log("WS:Update");
      rendergame();
    });
  }
   
  function enableCollapsables() {
    var coll = document.getElementsByClassName("collapsible");
    var i;

    for (i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.display === "block") {
          content.style.display = "none";
        } else {
          content.style.display = "block";
        }
      });
    }
  }
  
  </script>
 
</body>
</html>

