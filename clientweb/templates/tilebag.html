<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
  <link rel="shortcut icon" href="{{ url_for('.static', filename='favicon.ico') }}">
  <link rel="stylesheet" href="{{ url_for('.static', filename='tilebag.css') }}{{ cachefix }}">
  <link rel="stylesheet" href="{{ url_for('.static', filename='ticker.css') }}{{ cachefix }}">
  <link rel="stylesheet" href="{{ url_for('.static', filename='board.css') }}{{ cachefix }}">
   
  <!-- Include our javascript helpers -->
  <script src="{{ url_for('.static', filename='board.js') }}{{ cachefix }}"></script>
  <script src="{{ url_for('.static', filename='tiles.js') }}{{ cachefix }}"> </script>
    
   <!-- And our WebSocket helper -->
  <script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js" integrity="sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=" crossorigin="anonymous"></script>
   
</head>
<body>

<div class="header">
  <h1>TileBag!</h1>
  <p>Drag and Drop to make Game Actions</p>
</div>

</div>
<div class="mstick" id="messagebar">
  <div class="messages">
    <div class="gamemessage" id="gamemessage"></div>
    <div class="staticmessage" style="text-align:right; float:right">CURRENT PLAYER: <span id='currplayer'>Norm</span></div>
    <div class="staticmessage" id="players" style="float:middle"></div>
  </div>
</div>

<div class="row">
  <div class="infocolumn">
    <h2 style="text-align:center">PLAYER INFO</h2>
    <div class="row" id="playername" style="text-align:center; margin:3px;"></div>
    <div class="card">
      <div class="row">
        <h3 class="left60">BANK</h3>
        <span class="right30 playermoney" id="playermoney">$$$$$</span>
      </div>
    </div>
    <div class="card">
      <div class=row>
        <h3 class="left60">STOCK MARKET</h3>
        <button class="clr right30" onclick="clrCnt('S')" id="btnClearSCnt">Clear</button>
      </div>
      <div class="stockrack" id="stockrack">
        <!-- The following will dynamically be populated with
        <div class="stockspace">M</div> -->
      </div>
    </div>
    <div class="gamelog card">
      <div class=row>
        <h3 class="left60">GAME LOG</h3>
        <button class="clr right30" onclick="passTurn()" id="btnPass">End Turn</button>
      </div>
      <div class="currstate" id="gamestate"></div>
      <div class="messagelog"><ul id="messagelog"></ul></div>
    </div>
  </div>
  <div class="maincolumn">
    <div class="card">
      <h2>TILES</h2>
      <div class="tilerack" id="tilerack">
        <!-- The following will dynamically be populated with
        <div class="rackspace"></div>
             And each will eventually get populated with
        <div class="tile"><ctext>X</ctext><rtext>X</rtext></div>
        -->
      </div>
    </div>
    <div class="card">
      <div class="row">
        <div class="hotelcolumn">
          <div class=row>
            <h2 class="left60">HOTELS</h2>
            <button onclick="clrCnt('H')" class="right30 clr" id="btnClearHCnt">Clear</button>
          </div>
          <div class="hotellist" id="hotellist">
            <div class="rmhotelzone">
              <div class="rmhotelitem" id="rmhotelzone" style="border:none">Hotel Removal Zone</div>
            </div>
          </div>
        </div>
        <div class="boardcolumn">
          <div class=row>
            <h2 class="left60">BOARD</h2>
            <button onclick="onEndGame()" class="right30 clr" id="btnEndGame">End Game</button>
          </div>
          <div class="acquireBoard" style="height:300px;" id="acquireBoard"></div>
          <div class="row">
            <div id="outer">
              <!-- This div is important! 
              It lets us specify margin-left as percentage (in css loop) -->
              <div>
                  <div id="loop"><div id="content">Welcome to TileBag!&nbsp;</div></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="footer">
  <div class="card">
  <button type="button" class="collapsible">Instructions</button>
  <div class="content">
    <p>Instruction: All game actions are completed by dragging elements</p>
    <ul style="text-align:left">
      <li>Place a Tile - Drag tile to the board</li>
      <li>Buy a Stock - Drag hotel to the stock market</li>
      <li>Sell a Stock - Drag stock to the hotel area</li>
      <li>Place a Hotel - Click a tile on the board, Drag hotel to the board</li>
      <li>Remove a Hotel - Drag hotel to the "Remove" area</li>
    </ul>
    <p>Note: you are responsible for all game mechanics and logic beyond this (for now). I.e. you will have to determine the price of stocks, pay that from your wallet, and reconcile any hotel mergers. This logic might make it into the next version, so stay tuned!</p>
  </div>
  </div>
  <div class="card">
  <div class="hotellist"><img src="{{ url_for('.static', filename='stockchart.jpg') }}" alt="STOCK CHART" ></img></div>
  <h2>Footer</h2>
  </div>
  <div class="topnav" id="topnav">
</div>

<!-- ################################################################### --> 
<!-- ## Javascript for Rendering Game Components on the Screen -->
<!-- ################################################################### --> 
  <script>

  /* The hotel constants */
  let HOTELS = [
       {name: "Worldwide", short: "WW", color: "rgba(87, 54, 107, 1)"},
       {name: "Saxxon", short: "SX", color: "rgba(199, 140, 68, 1)"},
       {name: "Festival", short: "FV", color: "rgba(39, 117, 39, 1)"},
       {name: "Imperial", short: "IM", color:"rgba(181, 149, 45, 1)"},
       {name: "American", short: "AM", color: "rgba(45, 51, 140, 1)"},
       {name: "Continental", short: "CN", color: "rgba(156, 57, 26, 1)"},
       {name: "Tower", short: "TW", color: "rgba(115, 113, 112, 1)"},
   ];
    
  // The main window components we'll reference the most
  const el_topnav=document.getElementById("topnav");
  const el_hotellist=document.getElementById("hotellist");
  const el_rmhotelzone=document.getElementById("rmhotelzone");
  const el_stockrack=document.getElementById("stockrack");
  const el_tilerack=document.getElementById("tilerack");
  const el_gameboard=document.getElementById("acquireBoard")
  const el_gamestate=document.getElementById('gamestate');
  const el_pmoney=document.getElementById('playermoney');
  const el_moneyval=document.getElementById('moneyval'); // the widget
  const el_playerlist=document.getElementById('playerlist');
  const el_thisplayer=document.getElementById('playername');
  const el_players=document.getElementById('players');
  const el_currplayer=document.getElementById('currplayer');
  const el_btnEndGame=document.getElementById('btnEndGame');   
  const el_messagebar=document.getElementById('messagebar');
  const el_gamemessage=document.getElementById('gamemessage');
  const el_outer=document.getElementById('outer');
  const el_loop=el_outer.querySelector('#loop');

  // Helper functions
  const EFFECT_HIGHLIGHT='highlight'
  const EFFECT_SHOW='visible'
  const EFFECT_INDICATE='indicate'
  function addEffect(effect, elem) {
    if( !elem.className.includes(effect+" ") ) {
      elem.className = effect + " " + elem.className;
    }
  }
  function removeEffect(effect, elem) {
    elem.className = elem.className.replace(effect + " ", "");
  }
   
  // For TILERACK
  // Dynamically create the spots for the tiles
  // <div class="rackspace"></div>
  for(var i=0; i<7; i++){
    var rs=document.createElement('div');
    rs.className="rackspace";
    el_tilerack.append(rs);
  }
   
  // Draw the BOARD
  drawBoard(el_gameboard); // from board.js - draws an empty board

  // Called when a hotel tile starts or stops being dragged
  function onHotelDrag(hotel, done=false) {
    // TODO: See if the hotel is on the board or not
    if( !done ) {
      el_rmhotelzone.innerText = "Drop Here to Remove";
    }
    else {
      el_rmhotelzone.innerText = "Hotel Removal Zone";
    }
  }

  function getMultiSelectId(itemtype, hname) {
    return "ms_" + itemtype + "_" + hname;
  }

  function addMultiSelect(hostelm, itemtype) {
    var ms = document.createElement('span');
    ms.className="mscount";
    ms.id = getMultiSelectId(itemtype, hostelm.dataset.hotel);
    ms.dataset.count=0;
    hostelm.appendChild(ms);
    hostelm.onclick=function() {onMultiSelectClick(ms, itemtype);};
  }
   
  // Dynamically add the HOTELS tokens to the page
  const buildHotelName = function(hotel){
    // First Create the space for the hotel item
    var hs=document.createElement('div');
    hs.className="hotelspace";
    //el_hotellist.appendChild(hs);
    el_hotellist.insertBefore(hs, el_rmhotelzone.parentNode);
     
    // Then create the individual hotel and put it in that space
    var hi = document.createElement('div');
    hi.className="hotelitem";
    hi.id = hotel.name;
    hi.dataset.hotel=hotel.name;
    hs.appendChild(hi);
    hi.innerText=hotel.name;
    hi.dataset.hasmoved=false;
    hi.style.backgroundColor=hi.style.backgroundColor + " " +  hotel.color;
    hi.style.borderColor=hotel.color;

    // Create the "hidden" multi-select count part
    addMultiSelect(hi, "H");
     
    // Create the remaining stock count part
    var sc = document.createElement('span');
    sc.className="rmstockcount";
    sc.id = "sc_" + hotel.name;
    sc.innerText="#";
    hi.appendChild(sc)
     
    // drop hotel on stocks to buy stock, on board to place hotel
    makeTileDragable(hi, [[el_stockrack, 'buystock'],
                          [el_gameboard, 'placehotel'],
                          [el_rmhotelzone, 'rmhotel']], onHotelDrag);
  }
  HOTELS.forEach(h => buildHotelName(h));

  function _clrCnt(h, itemtype) {
   
    var elCnt=document.getElementById(getMultiSelectId(itemtype, h.name));
    elCnt.dataset.count=0;
    removeEffect(EFFECT_SHOW, elCnt);
  }

  function passTurn() {
    stockAction("Passing", 0);

    // Hide the button
    var elBtnPass=document.getElementById("btnPass");
    removeEffect(EFFECT_SHOW, elBtnPass);
  }

  function clrCnt(itemtype) {
    // Go through all count items, reset them and hide them
    HOTELS.forEach(h => _clrCnt(h, itemtype));
    
    // Hide the Clear Button
    var elClrStock=document.getElementById("btnClear"+itemtype+"Cnt");
    removeEffect(EFFECT_SHOW, elClrStock);
  }

  function onMultiSelectClick(mselem, itemtype) {
    if( mselem.parentElement.dataset.hasmoved == "false" )
    {
      var reqcount=parseInt(mselem.dataset.count);
      reqcount = isNaN(reqcount) ? 1 : reqcount+1;
      clrCnt(itemtype); // clear all others
      mselem.innerText=reqcount
      mselem.dataset.count=reqcount;
      addEffect(EFFECT_SHOW,mselem);
      var elClrBtn=document.getElementById("btnClear"+itemtype+"Cnt");
      addEffect(EFFECT_SHOW,elClrBtn);
    }
  }

  // Dynamically add the "buy/sell" STOCKS widgets to the page
  const buildStockWidget = function(hotel){
    // First Create the space for the stock item
    var ss=document.createElement('div');
    ss.className="stockspace";
    el_stockrack.append(ss);
     
    // Then create the individual stock and put it in that space
    var si=document.createElement('div');
    si.className="stockitem";
    si.id = "st_" + hotel.short;
    si.dataset.hotel=hotel.name; // required for multi-select
    si.style.backgroundColor=hotel.color;
    ss.append(si);
     
    // Create the "hidden" multi-select count part
    addMultiSelect(si, "S");
     
    var sia=document.createElement('div');
    sia.className="stockcount";
    var sib=document.createElement('div');
    sia.id=si.id + "_cnt";
    sia.innerText=0;
    sib.innerText=hotel.short;
    si.append(sia);
    si.append(sib);
     
    makeTileDragable(si, [[el_hotellist, 'sellstock']]);
  }
  HOTELS.forEach(h => buildStockWidget(h));
   
  enableCollapsables();
  function enableCollapsables() {
    var coll = document.getElementsByClassName("collapsible");
    var i;

    for (i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.display === "block") {
          content.style.display = "none";
        } else {
          content.style.display = "block";
        }
      });
    }
  }
  </script>
      
<!-- ################################################################### --> 
<!-- ## Javascript for Dynamic Game Effects from User actions -->
<!-- ################################################################### --> 
  <script>
  el_gameboard.addEventListener('playtile', tileDropped);
  el_gameboard.addEventListener('placehotel', placeHotel);
  el_stockrack.addEventListener('buystock', buyStock);
  el_hotellist.addEventListener('sellstock', sellStock);
  el_rmhotelzone.addEventListener('rmhotel', removeHotel);

  /* For TILES */
  function tileDropped(e){
    tile=e.detail.tile;
    if( {{debug}}  ) {
      tile.parentNode.removeChild(tile);
      placeTile(tile.innerText);
    } else {
      makeGameMove(tile); // post the move to the game server
    }
  }

  function onEndGame() {
    console.log("onEndGame pressed");
    sendEndGameRequest();
  }
   
  async function sendEndGameRequest() {
    // make REST call to change player hotel amounts by this
    const response = await fetch("{{ url_for('tilebagrest_blueprint.rest_tilebag_get_game_info', gameid=gameid, playerid=playerid) }}", {
                method: 'PATCH', 
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'endgame':'yeahletsdoit', 
                                    })
                },
              );
               
    await response.status;
    if( response.status != 200 ) {
      sendGameMessage("Refused to set End Game state");
    }
  }
   
     
  async function makeGameMove(tile)
  {
    const response = await fetch("{{ url_for('tilebagrest_blueprint.rest_tilebag_placetile', gameid=gameid, playerid=playerid) }}", {
                method: 'PATCH', 
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'action':'placetile', 
                                        'tile':tile.innerText})
                },
              );
                 
    await response.status;
    if( response.status == 200 ) {
      tile.parentNode.removeChild(tile);
    } else if( response.status == 400 ) {
      sendGameMessage("Not your turn");
    } else {
      sendGameMessage("Invalid Game Move");
    }
  }
   
  /* For HOTELS */
  async function placeHotel(e){
    hel=e.detail.tile;
     
    // make REST call to change player hotel amounts by this
    const response = await fetch("{{ url_for('tilebagrest_blueprint.rest_tilebag_placehotel', gameid=gameid, playerid=playerid) }}", {
                method: 'PATCH', 
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'action':'placeHotel', 
                                      'hotel' : hel.id,
                                      'tile' : 'lastplaced',
                                    })
                },
              );
               
    await response.status;
    if( response.status != 200 ) {
      sendGameMessage("Invalid Hotel Action");
    }
  }

  async function removeHotel(e){
    hel=e.detail.tile;
     
    // make REST call to change player hotel amounts by this
    const response = await fetch("{{ url_for('tilebagrest_blueprint.rest_tilebag_placehotel', gameid=gameid, playerid=playerid) }}", {
                method: 'PATCH', 
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'action':'placeHotel', 
                                      'hotel' : hel.id,
                                      'tile' : null,
                                    })
                },
              );
               
    await response.status;
    if( response.status != 200 ) {
      sendGameMessage("Invalid Remove-Hotel Action");
    }
  }

  function getCountFromMultSelect(itemtype, hname) {
    var elw=document.getElementById(getMultiSelectId(itemtype, hname));
    var count = 1;
    if( elw != undefined )
    {
      count=parseInt(elw.dataset.count);
      if( isNaN(count) || count == 0) {
        count = 1;
      }
       
      // Clear the "count" value from the element
      elw.dataset.count=0;
      removeEffect(EFFECT_SHOW, elw);
    }
    return count;
  }
   
  /* For STOCKS */
  function buyStock(e){
    // called with a hotelitem object
    var hotel=e.detail.tile;
    var hname=hotel.dataset.hotel;
    var buyCount=getCountFromMultSelect('H', hname);
     
    stockAction(hname, buyCount);
     
    var elClrHotel=document.getElementById("btnClearHCnt");
    removeEffect(EFFECT_SHOW, elClrHotel);
  }
   
  function sellStock(e){
    // called with a stockitem object
    var si=e.detail.tile;
    var hname=si.dataset.hotel;
    var sellCount=getCountFromMultSelect('S', hname);
       
    stockAction(hname, -sellCount);
     
    var elClrHotel=document.getElementById("btnClearSCnt");
    removeEffect(EFFECT_SHOW, elClrHotel);
  }
   
  async function stockAction(hname, amt){
    // make REST call to change player hotel amounts by this
    const response = await fetch("{{ url_for('tilebagrest_blueprint.rest_tilebag_stocks', gameid=gameid, playerid=playerid) }}", {
                method: 'PATCH', 
                headers: {
                  Accept: 'application/json',
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 'action':'buystocks', 
                                      'hotel' : hname,
                                      'amount' : amt,
                                    })
                },
              );
               
    await response.status;
    if( response.status != 200 ) {
      sendGameMessage("Invalid Stock Action");
    }
  }
   
  </script>
   
<!-- ################################################################### --> 
<!-- ## Javascript for Dynamic Game Effects from Server Messages -->
<!-- ################################################################### --> 
  <script>

  function sendGameMessage(message, error) {
    console.log(message);
    el_gamemessage.innerText=message;
    /*
    if( error === undefined || error == true ) {
      el_gamemessage.style.color = "red";
    } else {
      el_gamemessage.style.color = "white";
    }
    */
    el_gamemessage.className="gamemessage";
    if( error === undefined || error == true ) {
      el_messagebar.style.backgroundColor="red"
    }
    setTimeout(function(){
          el_gamemessage.className = 'gamemessage waa';
          el_messagebar.style.backgroundColor= '#333';
      }, 2500);
  }
     
  function showHotel(dhotel, ticker) {
    let h=HOTELS.find(o => o.name === dhotel['name']);
    let hel=document.getElementById(dhotel['name']);

    // Update the remaining stock count
    var sc=document.getElementById("sc_" + h.name);
    sc.innerText=dhotel['stocks'];
       
    // If it's on the board, show it on the board
    if( dhotel['tile'] != null) {
      // Update the stock ticker
      var sti=document.createElement('span');
      sti.style.color=h.color;
      sti.innerText=h.short+"("+dhotel['occupies'].length+") $" + dhotel['price'] + ";   ";
      ticker.appendChild(sti);
       
      // Colour the tiles on the board
      for( var i=0; i<dhotel['occupies'].length; i++)
      {
        var t = dhotel['occupies'][i];
        var cell=document.getElementById(t);
        if( cell != null)
        {
          cell.style.backgroundColor=h.color;
          cell.style.borderColor=h.color;
          cell.innerText = h.short;
          cell.style.fontSize="small";
          cell.className = cell.className + " honboard";
        }
      }

      // Tweak the hotel widget so it's clear it's on the board
      if( !hel.className.includes(" honboard") ) {
        hel.className = hel.className + " honboard";
      }
    }
    else
    {
      hel.className=hel.className.replace(" honboard", "");
    }
     
    // Grey out the widget based on how many stocks are left
    st=parseInt(dhotel['stocks']);
    var decksize = st / 25;
    if(st > 0){
      decksize += 0.5;
    }
    hel.style.opacity=decksize + 0.2;
  }
   
  // For the stock ticker
  function repeatContent(el, till) {
    let html = el.innerHTML;
    let counter = 0; // prevents infinite loop

    while (el.offsetWidth < till && counter < 100) {
        el.innerHTML += html;
        counter += 1;
    }
  }

  // game info only includes stocks we have, the rest are Zero
  function updateStocks(h, pstocks) {
    var stockval=0;
    var si=document.getElementById("st_" + h.short + "_cnt");
    if( pstocks[h.name] != undefined )
    {
      stockval=pstocks[h.name];
    }
    si.innerText=stockval;
  }

  function showPlayerInNav(pdata, pid, pname) {
    // Check if this id already exists, if not add it to the nav
    var pnavid="playernav_"+pid;
    var pnav=document.getElementById(pnavid);
    if( pnav === null ) {
      // New player! yay Friends!
       
      // For now, each player will be a link to their page <a href="#">Link</a>
      var name = document.createElement('a');
      name.id=pnavid;
      name.innerText=pname;
      name.href="{{gameid}}?playerid=" + pid;
      el_topnav.appendChild(name);
    }
  }

  function showPlayerInMStick(pdata, pid, pname) {
    // Check if this id already exists, if not add it to the nav
    var pindid="playerind_"+pid;
    var pind=document.getElementById(pindid);
    if( pind === null ) {
      // New player! yay Friends!
       
      // For now, each player will be a link to their page <a href="#">Link</a>
      var name = document.createElement('span');
      name.style.padding="2px 5px";
      name.id=pindid;
      name.innerText=pname;

      el_players.appendChild(name);
    }
    else
    {
      // Ensure they aren't highlighted
      removeEffect(EFFECT_HIGHLIGHT, pind);
      removeEffect(EFFECT_INDICATE, pind);
    }
  }

  function showPlayers(pdata) {
    var pid=pdata['id'];         // Shorthand for this function
    var pname=pdata['name'];

    showPlayerInNav(pdata, pid, pname)
    showPlayerInMStick(pdata, pid, pname)
  }
   
  async function rendergame(data) {
    // For testing, we may have called this function with data
    if( data === undefined ) {
      const response = await fetch("{{ url_for('tilebagrest_blueprint.rest_tilebag_get_game_info', gameid=gameid, playerid=playerid) }}");
       
      await response.status;
      if( response.status != 200 ) {
        sendGameMessage("Unable to get game state ?");
        return;
      }
       
      data = await response.json();
    }
     
    // GAMESTATE: Show the current action we're waiting on
    var currpname=data['game']['gamestate']['currplayer']['name'];
    var currpid=data['game']['gamestate']['currplayer']['id'];
    el_currplayer.innerText=currpname;
    el_gamestate.innerText=data['game']['gamestate']['message'];
    var elBtnPass=document.getElementById("btnPass");
    var state=data['game']['gamestate']['state']
    if( state == 'EndGame') {
      
    }
    if( state != 'BuyStocks' &&
        state != 'LiquidateStocks') { 
      removeEffect(EFFECT_SHOW, elBtnPass);
    }
    if( data['game']['endpossible'] ) {
      addEffect(EFFECT_SHOW, el_btnEndGame);
    } else {
      removeEffect(EFFECT_SHOW, el_btnEndGame);
    }

    // GAMELOG: Show the last messages
    var el_msgLog=document.getElementById("messagelog");
    var msgs=data['game']['gamelog'];
    el_msgLog.innerHTML="";
    for(var i=0; i<msgs.length; i++) {
      var li=document.createElement("li");
      var t=document.createTextNode(msgs[i]);
      li.appendChild(t);
      el_msgLog.appendChild(li);
    }
     
    // Show All the players and their names, highlight the current one
    data['game']['players'].forEach(pdata => showPlayers(pdata));
    var pwid=document.getElementById("playerind_"+currpid);
    if( pwid != null ) {
      addEffect(EFFECT_INDICATE, pwid);
    }

    // BOARD: Draw the board
    drawBoard(el_gameboard,data['game']['board']); // from board.js

    // HOTELS: Place the hotel tokens on the board
    el_loop.innerHTML="";           // clear the stock ticker first
    elt=document.createElement('div');
    elt.className='content';
    el_loop.appendChild(elt);
    hotels=data['game']['hotels'];
    hotels.forEach(h => showHotel(h,elt));
     
    // Draw the stock TICKER
    repeatContent(elt, el_outer.offsetWidth);
    el_loop.innerHTML=el_loop.innerHTML+el_loop.innerHTML;

    // see if we have a player or a spectator
    if( !data['game']['you'] ) {
      // TODO: some fancy spectator display
    } else {
      pinfo=data['game']['you']['playerdata'];
      el_thisplayer.innerText=data['game']['you']['name'];
      // Set Current player, highlight it if it's you
      if( data['game']['you']['id'] == data['game']['gamestate']['currplayer']['id']) {
        var elBtnPass=document.getElementById("btnPass");
        if(data['game']['gamestate']['state'] == 'BuyStocks' ||
           data['game']['gamestate']['state'] == 'LiquidateStocks') {
          addEffect(EFFECT_SHOW, elBtnPass);
        }
        addEffect(EFFECT_HIGHLIGHT, el_gamestate);
        addEffect(EFFECT_HIGHLIGHT, pwid); // defined well above
      }
      else
      {
        removeEffect(EFFECT_HIGHLIGHT, el_gamestate);
        removeEffect(EFFECT_HIGHLIGHT, pwid);
      }
      
      // PLAYER MONEY
      el_pmoney.innerText=(new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0,})).format(pinfo['money']);

      // STOCKS
      stocks=pinfo['stocks'];
      HOTELS.forEach(h => updateStocks(h, stocks));

      // PLAYER TILE RACK
      tiles=pinfo['tiles'];
      setTiles("rackspace", tiles, [[el_gameboard, 'playtile']]);
      showOptions(tiles);
    }
  }
  </script>
         
          
<!-- ################################################################### --> 
<!-- ## Javascript for loading / initializing the game (or demo) -->
<!-- ################################################################### --> 
  <script>
  if( {{debug}} ) {
    loadForDebug();
  } else {
    loadForReal();
  }
  sendGameMessage("Welcome!", false);
  

  function setupWebSocket() {

      var url=location.protocol + '//{{ serverroot }}';
      var socket = io.connect(url, {
                     'transports': ['websocket'],
                     'reconnection': true,
                     'reconnectionDelay': 1000,
                     'reconnectionDelayMax': 5000,
                     'reconnectionAttempts': 5,
                  });
      socket.emit('join', {'room':'{{ gameid }}'});     
      socket.on('connect', function() {
          console.log("*** WS:Connected: " + url);
      });

      socket.on('update', function(data) {
        console.log("WS:Update");
        rendergame();
      });
  }
  
  function loadForReal(){
    setupWebSocket();
    rendergame();
  }
   
  // When loading for twiddling with the client layout (no server to help)
  function loadForDebug(){
    tiles=gettiles();
    async function gettiles()
    {
        const response = await fetch("{{ url_for('testview_blueprint.get_tiles') }}");
        const data = await response.json();
        tiles=data['tiles'];
        setTiles("rackspace", tiles, [[acquireBoard,'playtile']]);
        showOptions(tiles);
         
        return tiles
    }
  }
  
  </script>
 
</body>
</html>

